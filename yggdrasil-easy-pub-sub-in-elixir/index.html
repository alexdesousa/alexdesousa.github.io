<!DOCTYPE html>
<html lang="en-US">
  <head><!-- general -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="An overview of Yggdrasil capabilities" />
<meta name="robots" content="index, follow">
<meta name="author" content="Alex de Sousa
" />

<!-- title -->
<title>Yggdrasil: Easy Pub-Sub in Elixir | Alex de Sousa's Blog</title>

<!--  canonical -->
<link rel="canonical" href="https://thebroken.link/yggdrasil-easy-pub-sub-in-elixir/"/>

<!-- favicon -->
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
<link rel="manifest" href="/assets/favicon/site.webmanifest">
<link rel="mask-icon" href="/assets/favicon/safari-pinned-tab.svg" color="#FFFFFF">
<meta name="msapplication-TileColor" content="#FFFFFF">
<meta name="theme-color" content="#FFFFFF">

<!-- Google card -->
<meta itemprop="description" content="An overview of Yggdrasil capabilities" />
<meta itemprop="image" content="https://thebroken.link/assets/img/yggdrasil-easy-pub-sub-in-elixir/tree.png" />

<!-- Facebook card -->
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Alex de Sousa's Blog" />
<meta property="og:title" content="Yggdrasil: Easy Pub-Sub in Elixir" />
<meta property="og:image" content="https://thebroken.link/assets/img/yggdrasil-easy-pub-sub-in-elixir/tree.png" />
<meta property="og:url" content="https://thebroken.link/yggdrasil-easy-pub-sub-in-elixir/" />
<meta property="og:description" content="An overview of Yggdrasil capabilities" />

<!-- Twitter card -->
<meta name="twitter:title" content="Yggdrasil: Easy Pub-Sub in Elixir" />
<meta name="twitter:description" content="An overview of Yggdrasil capabilities" />
<meta name="twitter:image" content="https://thebroken.link/assets/img/yggdrasil-easy-pub-sub-in-elixir/tree.png" />
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image:alt" content="Alex de Sousa's Blog">
<meta name="twitter:site" content="@thebroken_link">

<!-- styles --><link rel="stylesheet"
      href="/assets/css/article.css?version=20191116"><!-- metadata --><script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://thebroken.link/yggdrasil-easy-pub-sub-in-elixir/"
  },
  "headline": "Yggdrasil: Easy Pub-Sub in Elixir",
  "image": ["https://thebroken.link/assets/img/logo.png"],
  "datePublished": "2019-07-06T00:00:00+00:00",
  "dateModified": "2020-03-12T22:34:29+00:00",
  "author": {
    "@type": "Person",
    "name": "Alex de Sousa"
  },
  "description": "An overview of Yggdrasil capabilities"
}
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-85600451-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-85600451-1', {'anonymize_ip':true});
  </script><script type="text/javascript" src="/assets/js/app.js"></script>
</head>
  <body>
    <div class="page">
      <div class="navigation"><a class="navigation-logo" href="/">
  <img class="logo-image"
       alt="Alex de Sousa's Blog"
       src="/assets/img/logo.png"/>
</a>
<nav class="navigation-bar"><a href="/"
       class="nav-link-inactive">Blog</a><a href="/cv/"
       class="nav-link-inactive">CV</a></nav>
</div>
      <div class="content">
        <article class="article"><div class="header">
  <h1 class="title">Yggdrasil: Easy Pub-Sub in Elixir</h1><div class="header-info">
    <img class="header-info-child avatar"
         src="/assets/img/handle/alex.jpg"
         alt="Alex de Sousa
"/>
    <div class="header-info-child author">Alex de Sousa
</div>
    <div class="header-info-child read-time">7 min read</div>
    <a class="header-info-child share-button share-twitter"
       href="https://twitter.com/intent/tweet?text=An+overview+of+Yggdrasil+capabilities&url=https://thebroken.link/yggdrasil-easy-pub-sub-in-elixir/&via=thebroken_link"
       target="_blank">
    </a>
  </div></div>
<p>When I started coding in Elixir (around 2016), I was working for a financial company. Our product automatically invested money in the Forex market by copying traders&#39; actions (<em>market orders</em>) in real time. We had the following:<span class="article-image">
  <p class="article-image-caption">
    <img class="article-image"
         src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/system.png"
         alt="Our System"/></p>
</span>
In words, our system:</p>

<ol>
<li><strong>Subscribed</strong> to PostgreSQL for receiving <em>trader actions</em>.</li>
<li><strong>Published</strong> to RabbitMQ for:

<ul>
<li>Categorizing <em>trader actions</em>.</li>
<li>And enqueuing <em>trader actions</em> in the proper queue.</li>
</ul></li>
<li><strong>Subscribed</strong> to Redis for receiving updates on prices.</li>
<li><strong>Subscribed</strong> to several RabbitMQ queues for:

<ul>
<li>Receiving the categorized <em>trader actions</em>.</li>
<li>And deciding whether it should open/close some <em>market orders</em> or not.</li>
</ul></li>
<li>Opened and closed <em>market orders</em>.</li>
</ol>

<p>We needed to be able to communicate with three systems (PostgreSQL, RabbitMQ and Redis). However, in general, we only needed three actions:</p>

<ul>
<li><code>subscribe/1</code> to a channel.</li>
<li><code>publish/2</code> a message in a channel.</li>
<li><code>unsubscribe/1</code> from a channel.</li>
</ul>

<p>If we could generalize those three actions into an API, we could then implement three individual adapters for every system to handle the annoying stuff like disconnections, failures, resource management, protocols, etc.</p>

<p><img src="https://media.giphy.com/media/aih5IZkussTiE/giphy.gif" alt="hard"></p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
<li><a href="#I">Chapter I: Meet Yggdrasil</a></li>
<li><a href="#II">Chapter II: Yggdrasil and PostgreSQL Notifications</a></li>
<li><a href="#III">Chapter III: Yggdrasil and RabbitMQ Subscriptions</a></li>
<li><a href="#IV">In the end: One API to Rule Them All</a></li>
</ul>

<div class="chapter" style="background-color: var(--deep-blue);">
    <div class="chapter-content">
      <strong style="color: white;">CHAPTER I:</strong>
      <h2 id="I"
          class="chapter-title"
          style="color: white;">Meet Yggdrasil</h2>
      <img src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/chapter.png"
           alt="CHAPTER I: Meet Yggdrasil"/>
    </div>

<p></div></p>

<p>Handling subscriptions should be easy and, in an ideal world, we would only need to know <em>where</em> to connect and <em>start receiving</em> messages right away.</p>

<p>We shouldn&#39;t need to worry about secondary (yet relevant) things like disconnections, failures and managing resources.</p>

<p><img src="https://raw.githubusercontent.com/gmtprime/yggdrasil/master/priv/static/yggdrasil.png" alt="Yggdrasil"></p>

<blockquote>
<p><em>Yggdrasil</em> is an immense mythical tree that connects the nine worlds in Norse cosmology.</p>
</blockquote>

<p><a href="https://github.com/gmtprime/yggdrasil">Yggdrasil</a> was our pub-sub generalization. Using the strong foundations of Phoenix pub-sub library, we built an agnostic publisher/subscriber application that has:</p>

<ul>
<li>Multi node support.</li>
<li>Simple API: <code>subscribe/1</code>, <code>unsubscribe/1</code> and <code>publish/2</code>.</li>
<li>A <code>GenServer</code> wrapper for handling subscriber events easily.</li>
<li>A basic adapter for using Elixir message distribution.</li>
<li>Fault-tolerant adapters for:

<ul>
<li><a href="https://github.com/gmtprime/yggdrasil_redis">Redis</a>.</li>
<li><a href="https://github.com/gmtprime/yggdrasil_postgres">PostgreSQL</a>.</li>
<li><a href="https://github.com/gmtprime/yggdrasil_rabbitmq">RabbitMQ</a>.</li>
</ul></li>
</ul>

<h3 id="one-api-to-rule-them-all">One API to rule them all</h3>

<p>Yggdrasil&#39;s API is very simple:</p>

<ul>
<li>A process subscribes to <code>&quot;my_channel&quot;</code>:</li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir">   <span class="n">iex</span><span class="o">&gt;</span> <span class="ss">:ok</span> <span class="o">=</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">my_channel"</span><span class="p">)</span>
   <span class="n">iex</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
   <span class="p">{</span><span class="ss">:Y_CONNECTED</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">}}</span>
</code></pre></div>
<ul>
<li>A process (in this case the same process) publishes the message <code>&quot;my message&quot;</code> in <code>&quot;my_channel&quot;</code>.</li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir">   <span class="n">iex</span><span class="o">&gt;</span> <span class="ss">:ok</span> <span class="o">=</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">publish</span><span class="p">([</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">my_channel"</span><span class="p">],</span> <span class="sd">"</span><span class="s2">my message"</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>The message should be in the mailbox of the subscriber process:</li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir">   <span class="n">iex</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
   <span class="p">{</span><span class="ss">:Y_EVENT</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">},</span> <span class="sd">"</span><span class="s2">my message"</span><span class="p">}</span>
</code></pre></div>
<ul>
<li>The subscriber can unsubscribe from the channel to stop receiving messages:</li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir">   <span class="n">iex</span><span class="o">&gt;</span> <span class="ss">:ok</span> <span class="o">=</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">my_channel"</span><span class="p">)</span>
   <span class="n">iex</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
   <span class="p">{</span><span class="ss">:Y_DISCONNECTED</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">}}</span>
</code></pre></div>
<blockquote>
<p><code>flush()</code> cleans the IEx process mailbox. In general, receiving Yggdrasil messages should be the same as receiving messages when the sender uses <code>send/2</code>.</p>
</blockquote>

<p><img src="https://media.giphy.com/media/cdGQHR4Qzefx6/giphy.gif" alt="So easy!"></p>

<h3 id="yggdrasil-behaviour">Yggdrasil behaviour</h3>

<p>Yggdrasil provides a <code>behaviour</code> for writing subscribers easily. Following the previous example, the subscriber could be written as follows:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">Subscriber</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Yggdrasil</span>

  <span class="k">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="p">[</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">my_channel"</span><span class="p">]</span>
    <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[</span><span class="n">channel</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">handle_event</span><span class="p">(</span><span class="n">_channel</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">_state</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">inspect</span> <span class="p">{</span><span class="ss">:mailbox</span><span class="p">,</span> <span class="n">message</span><span class="p">}</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">nil</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>This subscriber will print the message as it receives it:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="o">&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">_pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">Subscriber</span><span class="o">.</span><span class="n">start_link</span><span class="p">()</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="ss">:ok</span> <span class="o">=</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">publish</span><span class="p">([</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">my_channel"</span><span class="p">],</span> <span class="sd">"</span><span class="s2">my message"</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:mailbox</span><span class="p">,</span> <span class="sd">"</span><span class="s2">my_message"</span><span class="p">}</span>
</code></pre></div>
<blockquote>
<p>An interesting side-effect is that now we can send messages to any process as long as they are subscribed to the right channel without needing to know the process PID or name.</p>
</blockquote>

<div class="chapter" style="background-color: var(--deep-blue);">
    <div class="chapter-content">
      <strong style="color: white;">CHAPTER II:</strong>
      <h2 id="II"
          class="chapter-title"
          style="color: white;">Yggdrasil and PostgreSQL Notifications</h2>
      <img src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/chapter.png"
           alt="CHAPTER II: Yggdrasil and PostgreSQL Notifications"/>
    </div>

<p></div></p>

<p>One thing I really like about PostgreSQL is its notifications via <code>pg_notify</code>. This feature is very useful when trying to get real-time notifications for certain changes in a databases.</p>

<h3 id="postgresql-notifications">PostgreSQL notifications</h3>

<p>Creating notifications in PostgreSQL is very easy e.g. let&#39;s say we have a table for books:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- User table creation</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">books</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">title</span> <span class="n">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">UNIQUE</span>
<span class="p">);</span>
</code></pre></div>
<p>and we want JSON notifications in the channel <code>new_books</code> every time a new book is created in our database e.g:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="s2">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="s2">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Animal Farm"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>The trigger could be implemented as follows:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="c1">-- Trigger function creation</span>
<span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">trigger_new_book</span><span class="p">()</span>
  <span class="k">RETURNS</span> <span class="k">TRIGGER</span> <span class="k">AS</span> <span class="err">$$</span>
  <span class="k">DECLARE</span>
    <span class="n">payload</span> <span class="n">JSON</span><span class="p">;</span>
  <span class="k">BEGIN</span>
    <span class="n">payload</span> <span class="p">:</span><span class="o">=</span> <span class="n">json_build_object</span><span class="p">(</span>
      <span class="s1">'id'</span><span class="p">,</span> <span class="k">NEW</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
      <span class="s1">'title'</span><span class="p">,</span> <span class="k">NEW</span><span class="p">.</span><span class="n">title</span>
    <span class="p">);</span>

    <span class="n">PERFORM</span> <span class="n">pg_notify</span><span class="p">(</span><span class="s1">'new_books'</span><span class="p">,</span> <span class="n">payload</span><span class="p">::</span><span class="n">TEXT</span><span class="p">);</span>
    <span class="k">RETURN</span> <span class="k">NEW</span><span class="p">;</span>
  <span class="k">END</span><span class="p">;</span>
  <span class="err">$$</span> <span class="k">LANGUAGE</span> <span class="n">plpgsql</span><span class="p">;</span>

<span class="c1">-- Sets the trigger function in 'books' table</span>
<span class="k">CREATE</span> <span class="k">TRIGGER</span> <span class="n">books_notify_new_book</span>
  <span class="k">BEFORE</span> <span class="k">INSERT</span> <span class="k">ON</span> <span class="n">books</span>
  <span class="k">FOR</span> <span class="k">EACH</span> <span class="k">ROW</span>
  <span class="k">EXECUTE</span> <span class="k">PROCEDURE</span> <span class="n">trigger_new_book</span><span class="p">();</span>
</code></pre></div>
<p>Then, the following query would trigger our JSON message in the channel <code>new_books</code>:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">books</span> <span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Animal Farm'</span><span class="p">);</span>
</code></pre></div>
<h3 id="the-problem">The Problem</h3>

<p>Though subscribing to our database notifications can be done easily with <a href="https://github.com/elixir-ecto/postgrex">Postgrex</a> library, handling the connections to the database is a bit of a hassle. We need to ensure:</p>

<ul>
<li><strong>Connection multiplexing</strong>: avoiding over consuming database resources.</li>
<li><strong>Fault-tolerant connections</strong>: supporting re-connections in case of failure or disconnection.</li>
<li><strong>Re-connection back-off time</strong>: avoiding overloading the database on multiple re-connections.</li>
</ul>

<p><img src="https://media.giphy.com/media/FrLKYbLI0djKU/giphy.gif" alt="problem"></p>

<h3 id="the-solution">The Solution</h3>

<p><a href="https://github.com/gmtprime/yggdrasil_postgres">Yggdrasil for PostgreSQL</a> is an adapter that supports all the features mentioned above while maintaining Yggdrasil&#39;s simple API e.g:</p>

<p>For our example, we could subscribe to the database messages by doing the following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="o">&gt;</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">new_books"</span><span class="p">,</span> <span class="ss">adapter:</span> <span class="ss">:postgres</span><span class="p">,</span> <span class="ss">transformer:</span> <span class="ss">:json</span><span class="p">)</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
<span class="p">{</span><span class="ss">:Y_CONNECTED</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">}}</span>
</code></pre></div>
<p>Running the following query:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">books</span> <span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'1984'</span><span class="p">);</span>
</code></pre></div>
<p>We will get the following message in IEx:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
<span class="p">{</span><span class="ss">:Y_EVENT</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">},</span> <span class="p">%{</span><span class="sd">"</span><span class="s2">id"</span> <span class="o">=&gt;</span> <span class="m">2</span><span class="p">,</span> <span class="sd">"</span><span class="s2">title"</span> <span class="o">=&gt;</span> <span class="sd">"</span><span class="s2">1984"</span><span class="p">}}</span>
</code></pre></div>
<blockquote>
<p><strong>Note</strong>: <code>Yggdrasil</code> comes with built-in message transformers. We&#39;ve used
<code>:json</code> transformer for this example in order to get a map from the JSON
data.</p>
</blockquote>

<p>Additionally, our subscriber could also be an <code>Yggdrasil</code> process e.g:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">Books</span><span class="o">.</span><span class="no">Subscriber</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Yggdrasil</span>

  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">options</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="p">[</span>
      <span class="ss">name:</span> <span class="sd">"</span><span class="s2">new_books"</span><span class="p">,</span>
      <span class="ss">adapter:</span> <span class="ss">:postgres</span><span class="p">,</span>
      <span class="ss">transformer:</span> <span class="ss">:json</span>
    <span class="p">]</span>

    <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">handle_event</span><span class="p">(</span><span class="n">_channel</span><span class="p">,</span> <span class="p">%{</span><span class="sd">"</span><span class="s2">id"</span> <span class="o">=&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="sd">"</span><span class="s2">title"</span> <span class="o">=&gt;</span> <span class="n">title</span><span class="p">},</span> <span class="n">_state</span><span class="p">)</span> <span class="k">do</span>
    <span class="o">...</span> <span class="n">handle</span> <span class="n">event</span> <span class="o">...</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">nil</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>It&#39;s also possbible to use <code>Yggdrasil.publish/2</code> with PostgreSQL:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">message</span> <span class="o">=</span> <span class="p">%{</span><span class="sd">"</span><span class="s2">id"</span> <span class="o">=&gt;</span> <span class="m">3</span><span class="p">,</span> <span class="sd">"</span><span class="s2">title"</span> <span class="o">=&gt;</span> <span class="sd">"</span><span class="s2">A Brave New World"</span><span class="p">}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">publish</span><span class="p">([</span><span class="ss">name:</span> <span class="sd">"</span><span class="s2">new_books"</span><span class="p">,</span> <span class="ss">adapter:</span> <span class="ss">:postgres</span><span class="p">,</span> <span class="ss">transformer:</span> <span class="ss">:json</span><span class="p">],</span> <span class="n">message</span><span class="p">)</span>
</code></pre></div>
<p><img src="https://media.giphy.com/media/zcCGBRQshGdt6/giphy.gif" alt="Too easy!"></p>

<div class="chapter" style="background-color: var(--deep-blue);">
    <div class="chapter-content">
      <strong style="color: white;">CHAPTER III:</strong>
      <h2 id="III"
          class="chapter-title"
          style="color: white;">Yggdrasil and RabbitMQ Subscriptions</h2>
      <img src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/chapter.png"
           alt="CHAPTER III: Yggdrasil and RabbitMQ Subscriptions"/>
    </div>

<p></div></p>

<p>One of the features I really like about RabbitMQ is its queue routing. Its flexibility allows you to do interesting things without much of a hassle. But before I dig deep into RabbitMQ&#39;s routing capabilities, I would like to mention some concepts.</p>

<h3 id="connections-and-channels">Connections and Channels</h3>

<p>RabbitMQ uses not only <strong>connections</strong>, but virtual connections called <strong>channels</strong>. The idea of channels is to introduce multiplexing in a single connection. A small system could establish only one connection with RabbitMQ while opening a channel for every single execution thread e.g:<span class="article-image">
  <p class="article-image-caption">
    <img class="article-image"
         src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/rabbitmq-connection.png"
         alt="RabbitMQ channel multiplexing"/></p>
</span>
The rule of thumb would be to use:</p>

<ul>
<li>One connection per application.</li>
<li>One channel per process in the application.</li>
</ul>

<blockquote>
<p><strong>Note</strong>: Once our connection starts to be overloaded, we can start adding more connections to our connection pool.</p>
</blockquote>

<p>With a normal RabbitMQ setup, we need to deal with:</p>

<ul>
<li><strong>Connection pools</strong>: avoiding over consuming resources.</li>
<li><strong>Channel cleaning</strong>: avoiding channel memory leaks when they are not closed properly.</li>
<li><strong>Fault-tolerant connections</strong>: supporting re-connections in case of failure or disconnection.</li>
<li><strong>Re-connection back-off time</strong>: avoiding overloading the database on multiple re-connections.</li>
</ul>

<h3 id="exchanges-and-queues">Exchanges and Queues</h3>

<p>An <strong>exchange</strong> is a message router. Every <strong>queue</strong> attached to it will be identified by a <strong>routing key</strong>. Typically, routing keys are words separated by dots e.g. <code>spain.barcelona.gracia</code>.</p>

<p>Additionally, routing keys support wildcards, for example: <code>spain.barcelona.*</code> will match messages with routing keys like <code>spain.barcelona.gracia</code> and <code>spain.barcelona.raval</code>.</p>

<p>It&#39;s easier to see these concepts with an image example:<span class="article-image">
  <p class="article-image-caption">
    <img class="article-image"
         src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/rabbitmq-exchange.png"
         alt="RabbitMQ exchange routing"/></p>
</span>
In the previous image:</p>

<ul>
<li><strong><strong>Publisher X</strong></strong> and <strong><strong>Publisher Y</strong></strong> are sending messages to <strong><em>Exchange logs</em></strong>.</li>
<li><strong><strong>Subscriber A</strong></strong> is subscribed to <code>logs.*</code>.</li>
<li><strong><strong>Subscriber B</strong></strong> is subscribed to <code>logs.error</code>.</li>
</ul>

<p>Then:</p>

<ul>
<li><strong><strong>Publisher X</strong></strong> message will end up in <strong><em>Queue</em></strong> <code>logs.info</code>.</li>
<li><strong><strong>Publisher Y</strong></strong> message will end up in <strong><em>Queue</em></strong> <code>logs.error</code>.</li>
<li><strong><strong>Subscriber A</strong></strong> will receive <strong><strong>Publisher X</strong></strong> and <strong><strong>Publisher Y</strong></strong>&#39;s messages.</li>
<li><strong><strong>Subscriber B</strong></strong> will receive <strong><strong>Publisher Y</strong></strong>&#39;s message.</li>
</ul>

<p><img src="https://media.giphy.com/media/3o6gDSdED1B5wjC2Gc/giphy.gif" alt="Information Overload"></p>

<h3 id="handling-subscriptions-in-yggdrasil">Handling Subscriptions in Yggdrasil</h3>

<p>Handling RabbitMQ&#39;s complexity might be intimidating. Fortunately, <a href="https://github.com/gmtprime/yggdrasil_rabbitmq">Yggdrasil for RabbitMQ</a> generalizes the complexity in order to have a simpler API.</p>

<p>The biggest difference with previous adapters is the channel name. Instead of being a string, it&#39;s a tuple with the exchange name and the routing key e.g:</p>

<p>A subscriber would connect to the exchange <code>amq.topic</code> using the routing key <code>logs.*</code> as follows:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="ss">name:</span> <span class="p">{</span><span class="sd">"</span><span class="s2">amq.topic"</span><span class="p">,</span> <span class="sd">"</span><span class="s2">logs.*"</span><span class="p">},</span> <span class="ss">adapter:</span> <span class="ss">:rabbitmq</span><span class="p">)</span>
<span class="n">iex</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
<span class="p">{</span><span class="ss">:Y_CONNECTED</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">}}</span>
</code></pre></div>
<blockquote>
<p><strong>Note</strong>: The exchange must exist and its type should be <code>topic</code>. The exchange <code>amq.topic</code> is created by default in RabbitMQ.</p>
</blockquote>

<p>Then a publisher could send a message to the exchange <code>amq.topic</code> using <code>logs.info</code> as routing key:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="p">(</span><span class="n">publisher</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">publish</span><span class="p">([</span><span class="ss">name:</span> <span class="p">{</span><span class="sd">"</span><span class="s2">amq.topic"</span><span class="p">,</span> <span class="sd">"</span><span class="s2">logs.info"</span><span class="p">},</span> <span class="ss">adapter:</span> <span class="ss">:rabbitmq</span><span class="p">],</span> <span class="sd">"</span><span class="s2">Some message"</span><span class="p">)</span>
<span class="ss">:ok</span>
</code></pre></div>
<p>Finally, the subscriber would receive the message:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">flush</span><span class="p">()</span>
<span class="p">{</span><span class="ss">:Y_EVENT</span><span class="p">,</span> <span class="p">%</span><span class="no">Yggdrasil</span><span class="o">.</span><span class="no">Channel</span><span class="p">{</span><span class="o">...</span><span class="p">},</span> <span class="sd">"</span><span class="s2">Some message"</span><span class="p">}</span>
</code></pre></div>
<p>Additionally, the subscriber can be written using the <code>Yggdrasil</code> behaviour:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">Logs</span><span class="o">.</span><span class="no">Subscriber</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Yggdrasil</span>

  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">options</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="p">[</span>
      <span class="ss">name:</span> <span class="p">{</span><span class="sd">"</span><span class="s2">amq.topic"</span><span class="p">,</span> <span class="sd">"</span><span class="s2">logs.*"</span><span class="p">},</span>
      <span class="ss">adapter:</span> <span class="ss">:rabbitmq</span>
    <span class="p">]</span>

    <span class="no">Yggdrasil</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">handle_event</span><span class="p">(</span><span class="n">_channel</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">_state</span><span class="p">)</span> <span class="k">do</span>
    <span class="o">...</span> <span class="n">handle</span> <span class="n">event</span> <span class="o">...</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">nil</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h3 id="lost-messages">Lost Messages</h3>

<p>Yggdrasil will acknowledge the messages as soon as they arrive to the adapter, then it will broadcast them to all the subscribers. If the adapter is alive while the subscribers are restarting/failing, some messages might be lost.</p>

<p>Though it&#39;s possible to overcome this problem with exclusive queues, this feature is not implemented yet.</p>

<p><img src="https://media.giphy.com/media/5YuhLwDgrgtRVwI7OY/giphy.gif" alt="Penguin&#39;s queueing"></p>

<div class="chapter" style="background-color: var(--deep-blue);">
    <div class="chapter-content">
      <strong style="color: white;">IN THE END:</strong>
      <h2 id="IV"
          class="chapter-title"
          style="color: white;">One API to Rule Them All</h2>
      <img src="/assets/img/yggdrasil-easy-pub-sub-in-elixir/chapter.png"
           alt="IN THE END: One API to Rule Them All"/>
    </div>

<p></div></p>

<p><a href="https://github.com/gmtprime/yggdrasil">Yggdrasil</a> hides the complexity of a pub/sub and let&#39;s you focus in what really matters: <strong>messages</strong>.</p>

<p>Hope you found this article useful. Happy coding!</p>

<p><img src="https://media.giphy.com/media/26xBENWdka2DSvvag/giphy.gif" alt="Heck yeah!"></p>
</article><hr><div class="bio-info">
    <img class="bio-info-child bio-avatar"
         src="/assets/img/handle/alex.jpg"
         alt="Alex de Sousa
"/>
    <div class="bio-info-child author">Alex de Sousa
</div>
    <div class="bio-info-child bio-description"><a href="https://refillaqua.com">Refill Aqua</a> co-founder. Elixir alchemist. Tech enthusiast.
</div>
  </div><div class="boxes"><!-- Next article --><div class="box">
  <img class="box-child box-image"
       alt="Skogsrå: Simplifying Your Elixir Configuration"
       src="https://thebroken.link/assets/img/skogsra-simplifying-your-elixir-configuration/skogsra.jpg"/>
  <span class="box-child box-read-time">3 min read</span>
  <a class="box-child box-title nav-link-inactive"
     href="/skogsra-simplifying-your-elixir-configuration/">Skogsrå: Simplifying Your Elixir Configuration</a>
  <span class="box-child box-description">Improving Elixir configurations for small and large projects.</span>
</div>
<!-- Previous article --><div class="box">
  <img class="box-child box-image"
       alt="Syntax highlighting in Jekyll"
       src="https://thebroken.link/assets/img/syntax-highlighting-in-jekyll/jekyll.png"/>
  <span class="box-child box-read-time">1 min read</span>
  <a class="box-child box-title nav-link-inactive"
     href="/syntax-highlighting-in-jekyll/">Syntax highlighting in Jekyll</a>
  <span class="box-child box-description">Using Redcarpet markdown renderer to add pygments to Jekyll</span>
</div>
</div></div>
      <div class="footer"><div class="footer-copyright">
  <span class="by-alex-de-sousa"> Copyright 2020 Alex de Sousa</span>
</div>
<div class="footer-social-media">
  <a href="https://github.com/alexdesousa">
    <img class="social-media github"
        src="/assets/img/social/github.png"
        alt="Twitter"/>
  </a>
  <a href="https://twitter.com/thebroken_link">
    <img class="social-media twitter"
        src="/assets/img/social/twitter.png"
        alt="Twitter"/>
  </a>
</div>
</div>
    </div>
  </body>
</html>
