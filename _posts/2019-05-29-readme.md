---
layout: article
title: The Broken Link Blog
description: Createa a blog using GitHub pages
author: Alex de Sousa
---

> Broken or dead link, a link that, having suffered link rot, points to a
> webpage or server that is no longer available on the World Wide Web.

This project is my personal blog. Maintaining a blog should be simple: writing
some content, adding some images if needed, commit the changes and that's it.
This is my solution to solve this problem.

## What's Wrong With Medium?

Nothing, really. Their business is to host blogs for free and then monetize the
contents others create. If something is free, you're the product.

The same happens with Github. Their business is to host code for free and
provide the tools (and tools for integrating more useful tools) so developers
are hooked. Again, if something is free, you're the product.

I chose hosting my blog in GitHub because:

- I can write my blog using the same tools I use for writing code: `vim`, `zsh`
  and `git`. I feel confortable in this cocoon I've created and I feel more
  creative inside of it.
- I have a backup by default in my computer. If somehow someone at GitHub
  decides my ideas shouldn't be heard, then I would have the content I've
  created. Censorship is sometimes a consequence of centralization.
- I don't like Medium's business model.

## Why Ruby?

I don't love Ruby. I also don't hate it. Howeverm, my professional experience
does not include Ruby. So... Why Jekyll?

- Amazing documentation.
- Easy to use.
- Awesome plugins.
- No need of Ruby knowledge or, at least, not too much.

There's a great
[step-by-step Jekyll tutorial](https://jekyllrb.com/docs/step-by-step/01-setup/)
in their webpage. Everything said here only documents my experience following
it plus some other useful tips.

## Installing Ruby

For installing Ruby, I used the same method I used for Elixir and Erlang:
`asdf` (for more information about it just check the
[project's GitHub page](https://github.com/asdf-vm/asdf))

First, I installed the Ruby plugin and the latest version of the language for
the project

```bash
$ asdf plugin-add ruby    # For installing the plugin for Ruby
$ asdf install ruby 2.6.3 # Installs the latest version for Ruby
$ asdf local ruby 2.6.3   # Sets the project's Ruby version in `tool-versions`
```

Then, I installed `bundler` package:

```bash
$ gem install bundler
```

Finally, having `bundler` installed, I can init a new Ruby project:

```bash
$ bundle init
```

## Installing Jekyll

This is a programming blog, so for me is very important to have great support
for code blocks. Personally, I like
[Monokai theme](https://raw.githubusercontent.com/jwarby/pygments-css/master/monokai.css)
from
[jwarby Jekyll's pygments themes](http://jwarby.github.io/jekyll-pygments-themes/languages/javascript.html).

Having that in mind, I chose the following requirements:

- `jekyll`, of course.
- `redcarpet` for handling my markdown using pygments syntax highlight.

So, my `Gemfile` looks something like the following:

```ruby
source "https://rubygems.org"

gem "jekyll"
gem "redcarpet"
```

## Getting Started

Jekyll has a specific way of dealing with templates and assets. The following
is a general description of each file/folder:

- `_config.yml`: Jekyll configuration.
- `_layouts`: folder for HTML templates for every page.
- `_includes`: folder for reusable HTML templates. Things like navigation bars,
  reading time widgets, among others should be placed here.
- `_posts`: folder for the posts.
- `assets/css`: folder for the CSS of the webpage.
- `index.html`: default entry point for your webpage.

> **Note**: There are more things you can do, like adding JS files to do fancy
> stuff, but it goes out of the scope of this article.

## Code Block Configuration

If we want to use syntax highlight, we should configure `redcarpet` markdown
gem as follows:

```yaml
markdown: redcarpet
redcarpet:
  extensions: [
    "no_intra_emphasis",
    "fenced_code_blocks",
    "autolink",
    "strikethrough",
    "superscript"
  ]
```

and copy our pygments CSS file to `assets/css/pygments` e.g. `monokai.css` and
include it in our `assets/css/main.css`:

```css
@import url(pygments/monokai.css);

code {
  color: #FFFFFF;
  background-color: #272822;
  padding: 2px 3px 2px 3px;
  border-radius: 3px;
}

... more custom CSS ...
```

Finally, we need to include `assets/css/main.css` in any of our templates e.g:
`_includes/head.html` for managing our `head` HTML tag:

```html
<head>
  <title>{{ page.title }}</title>
  <link rel="stylesheet" href="{{ "/assets/css/main.css?version=20190529" | prepend: site.baseurl }}">
</head>
```

> **Note**: `page.title` and `site.baseurl` are template variables.

## Our First Template

Adding `_include/head.html` in my template `_layouts/default.html` is now
very simple:

{% raw %}
```html
<!doctype html>
<html>

  {% include head.html %}

  <body>
    <article>
      {{ content }}
    </article>
  </body>
</html>
```
{% endraw %}

and using the template would be as simple as creating a markdown file e.g. in
the root of the project we create `example.md` as follows:

```markdown
---
layout: default
title: Example
---

# My Example

This is a

    IO.puts "Example"
```

Finally, by running the following:

```bash
$ bundle exec jekyll serve
```

and going to `localhost:4000/example.md` in our browser. We can see our
`example.md` file rendered.

## First Post

The same applies for blog posts. If we create a markdown file with the
following name format:

```
<YYYY>-<MM>-<DD>-<name of the article>.md
```

where:

- `<YYYY>` is a four digit number representing the year.
- `<MM>` is a two digit number representing the month.
- `<DD>` is a two digit number representing the day.

e.g. if we `mv` our `example.md` file to `_posts/2019-05-29-example.md`, we can
find the page rendered in `localhost:4000/2019/05/29/example.md`.

## Deploy!

TODO
